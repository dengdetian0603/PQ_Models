if (length(ss.avail) > 0) {
H[, ss.avail] = t(t(H[, ss.avail]) +
digamma(par.list$B_st[ss.avail]) -
digamma(par.list$A_st[ss.avail] +
par.list$B_st[ss.avail])) +
MSS.case[, ss.avail] * 1e+16
}
qL = LoopyUpdateQL(par.list$qL, par.list$qD, H,
par.list$mu_rho, nloop = 4)
par.list$qL = qL
# update A, B
## silver
q.sum = colSums(par.list$qL[, ss.avail], TRUE)
if (length(ss.avail) > 0) {
qMs.sum = colSums(par.list$qL[, ss.avail] * MSS.case[, ss.avail], TRUE)
par.list$A_st[ss.avail] = qMs.sum + hyper.par.list$aa[ss.avail]
par.list$B_st[ss.avail] = q.sum - qMs.sum + hyper.par.list$bb[ss.avail]
}
## bronze
qMb.sum = colSums(par.list$qL[, bs.avail] * MBS.case[, bs.avail], TRUE)
par.list$A_bt[bs.avail] = qMb.sum + hyper.par.list$cc
par.list$B_bt[bs.avail] = q.sum - qMb.sum + hyper.par.list$dd
Msum.case = colSums(MBS.case[, bs.avail], TRUE)
Msum.ctrl = colSums(MBS.ctrl[, bs.avail], TRUE)
par.list$A_bf[bs.avail] = Msum.case + Msum.ctrl -
qMb.sum + hyper.par.list$ee
par.list$B_bf[bs.avail] = n.case + n.ctrl + qMb.sum - q.sum -
Msum.case - Msum.ctrl + hyper.par.list$ff
# update mu_theta, tau_theta
qLD = par.list$qL %*% par.list$qD
theta.update = UpdateTheta(par.list$mu_theta, par.list$qL, par.list$qD, qLD,
par.list$mu_rho, par.list$tau_rho,
hyper.par.list$theta_mu,
hyper.par.list$theta_tau)
par.list$mu_theta = theta.update$mu.theta
par.list$tau_theta = theta.update$tau.theta
# update mu_rho, tau_rho
rho.update = UpdateRho(par.list$mu_rho, par.list$qL, qLD,
par.list$mu_theta, par.list$tau_theta,
hyper.par.list$rho_mu, hyper.par.list$rho_tau)
par.list$mu_rho = rho.update$mu.rho
par.list$tau_rho = rho.update$tau.rho
LoopyUpdateQD(par.list, qLD,
hyper.par.list$pind_a, hyper.par.list$pind_b)
Rcpp::sourceCpp('VBEM_Update.cpp')
par.list = SetVBInitialValues(5, input.obj, hyper.pars.list)
H = matrix(par.list$mu_theta, nrow = n.case,
ncol = ncol(MBS.case), byrow = TRUE)
psi.A.A = (digamma(par.list$A_bt) - digamma(par.list$A_bf))[bs.avail]
psi.B.B = (digamma(par.list$B_bt) - digamma(par.list$B_bf))[bs.avail]
psi.A.B = (digamma(par.list$A_bf + par.list$B_bf) -
digamma(par.list$A_bt + par.list$B_bt))[bs.avail]
H.bs = t(t(MBS.case[, bs.avail]) * psi.A.A +
t(1 - MBS.case[, bs.avail]) * psi.B.B + psi.A.B)
H[, bs.avail] = H[, bs.avail] + H.bs
if (length(ss.avail) > 0) {
H[, ss.avail] = t(t(H[, ss.avail]) +
digamma(par.list$B_st[ss.avail]) -
digamma(par.list$A_st[ss.avail] +
par.list$B_st[ss.avail])) +
MSS.case[, ss.avail] * 1e+16
}
qL = LoopyUpdateQL(par.list$qL, par.list$qD, H,
par.list$mu_rho, nloop = 4)
par.list$qL = qL
# update A, B
## silver
q.sum = colSums(par.list$qL[, ss.avail], TRUE)
if (length(ss.avail) > 0) {
qMs.sum = colSums(par.list$qL[, ss.avail] * MSS.case[, ss.avail], TRUE)
par.list$A_st[ss.avail] = qMs.sum + hyper.par.list$aa[ss.avail]
par.list$B_st[ss.avail] = q.sum - qMs.sum + hyper.par.list$bb[ss.avail]
}
## bronze
qMb.sum = colSums(par.list$qL[, bs.avail] * MBS.case[, bs.avail], TRUE)
par.list$A_bt[bs.avail] = qMb.sum + hyper.par.list$cc
par.list$B_bt[bs.avail] = q.sum - qMb.sum + hyper.par.list$dd
Msum.case = colSums(MBS.case[, bs.avail], TRUE)
Msum.ctrl = colSums(MBS.ctrl[, bs.avail], TRUE)
par.list$A_bf[bs.avail] = Msum.case + Msum.ctrl -
qMb.sum + hyper.par.list$ee
par.list$B_bf[bs.avail] = n.case + n.ctrl + qMb.sum - q.sum -
Msum.case - Msum.ctrl + hyper.par.list$ff
# update mu_theta, tau_theta
qLD = par.list$qL %*% par.list$qD
theta.update = UpdateTheta(par.list$mu_theta, par.list$qL, par.list$qD, qLD,
par.list$mu_rho, par.list$tau_rho,
hyper.par.list$theta_mu,
hyper.par.list$theta_tau)
par.list$mu_theta = theta.update$mu.theta
par.list$tau_theta = theta.update$tau.theta
# update mu_rho, tau_rho
rho.update = UpdateRho(par.list$mu_rho, par.list$qL, qLD,
par.list$mu_theta, par.list$tau_theta,
hyper.par.list$rho_mu, hyper.par.list$rho_tau)
par.list$mu_rho = rho.update$mu.rho
par.list$tau_rho = rho.update$tau.rho
# update qD
qD = LoopyUpdateQD(par.list, qLD,
hyper.par.list$pind_a, hyper.par.list$pind_b)
Rcpp::sourceCpp('VBEM_Update.cpp')
par.list = SetVBInitialValues(5, input.obj, hyper.pars.list)
H = matrix(par.list$mu_theta, nrow = n.case,
ncol = ncol(MBS.case), byrow = TRUE)
psi.A.A = (digamma(par.list$A_bt) - digamma(par.list$A_bf))[bs.avail]
psi.B.B = (digamma(par.list$B_bt) - digamma(par.list$B_bf))[bs.avail]
psi.A.B = (digamma(par.list$A_bf + par.list$B_bf) -
digamma(par.list$A_bt + par.list$B_bt))[bs.avail]
H.bs = t(t(MBS.case[, bs.avail]) * psi.A.A +
t(1 - MBS.case[, bs.avail]) * psi.B.B + psi.A.B)
H[, bs.avail] = H[, bs.avail] + H.bs
if (length(ss.avail) > 0) {
H[, ss.avail] = t(t(H[, ss.avail]) +
digamma(par.list$B_st[ss.avail]) -
digamma(par.list$A_st[ss.avail] +
par.list$B_st[ss.avail])) +
MSS.case[, ss.avail] * 1e+16
}
qL = LoopyUpdateQL(par.list$qL, par.list$qD, H,
par.list$mu_rho, nloop = 4)
par.list$qL = qL
# update A, B
## silver
q.sum = colSums(par.list$qL[, ss.avail], TRUE)
if (length(ss.avail) > 0) {
qMs.sum = colSums(par.list$qL[, ss.avail] * MSS.case[, ss.avail], TRUE)
par.list$A_st[ss.avail] = qMs.sum + hyper.par.list$aa[ss.avail]
par.list$B_st[ss.avail] = q.sum - qMs.sum + hyper.par.list$bb[ss.avail]
}
## bronze
qMb.sum = colSums(par.list$qL[, bs.avail] * MBS.case[, bs.avail], TRUE)
par.list$A_bt[bs.avail] = qMb.sum + hyper.par.list$cc
par.list$B_bt[bs.avail] = q.sum - qMb.sum + hyper.par.list$dd
Msum.case = colSums(MBS.case[, bs.avail], TRUE)
Msum.ctrl = colSums(MBS.ctrl[, bs.avail], TRUE)
par.list$A_bf[bs.avail] = Msum.case + Msum.ctrl -
qMb.sum + hyper.par.list$ee
par.list$B_bf[bs.avail] = n.case + n.ctrl + qMb.sum - q.sum -
Msum.case - Msum.ctrl + hyper.par.list$ff
# update mu_theta, tau_theta
qLD = par.list$qL %*% par.list$qD
theta.update = UpdateTheta(par.list$mu_theta, par.list$qL, par.list$qD, qLD,
par.list$mu_rho, par.list$tau_rho,
hyper.par.list$theta_mu,
hyper.par.list$theta_tau)
par.list$mu_theta = theta.update$mu.theta
par.list$tau_theta = theta.update$tau.theta
# update mu_rho, tau_rho
rho.update = UpdateRho(par.list$mu_rho, par.list$qL, qLD,
par.list$mu_theta, par.list$tau_theta,
hyper.par.list$rho_mu, hyper.par.list$rho_tau)
par.list$mu_rho = rho.update$mu.rho
par.list$tau_rho = rho.update$tau.rho
# update qD
qD = LoopyUpdateQD(par.list, qLD,
hyper.par.list$pind_a, hyper.par.list$pind_b)
Rcpp::sourceCpp('VBEM_Update.cpp')
par.list = SetVBInitialValues(5, input.obj, hyper.pars.list)
H = matrix(par.list$mu_theta, nrow = n.case,
ncol = ncol(MBS.case), byrow = TRUE)
psi.A.A = (digamma(par.list$A_bt) - digamma(par.list$A_bf))[bs.avail]
psi.B.B = (digamma(par.list$B_bt) - digamma(par.list$B_bf))[bs.avail]
psi.A.B = (digamma(par.list$A_bf + par.list$B_bf) -
digamma(par.list$A_bt + par.list$B_bt))[bs.avail]
H.bs = t(t(MBS.case[, bs.avail]) * psi.A.A +
t(1 - MBS.case[, bs.avail]) * psi.B.B + psi.A.B)
H[, bs.avail] = H[, bs.avail] + H.bs
if (length(ss.avail) > 0) {
H[, ss.avail] = t(t(H[, ss.avail]) +
digamma(par.list$B_st[ss.avail]) -
digamma(par.list$A_st[ss.avail] +
par.list$B_st[ss.avail])) +
MSS.case[, ss.avail] * 1e+16
}
qL = LoopyUpdateQL(par.list$qL, par.list$qD, H,
par.list$mu_rho, nloop = 4)
par.list$qL = qL
# update A, B
## silver
q.sum = colSums(par.list$qL[, ss.avail], TRUE)
if (length(ss.avail) > 0) {
qMs.sum = colSums(par.list$qL[, ss.avail] * MSS.case[, ss.avail], TRUE)
par.list$A_st[ss.avail] = qMs.sum + hyper.par.list$aa[ss.avail]
par.list$B_st[ss.avail] = q.sum - qMs.sum + hyper.par.list$bb[ss.avail]
}
## bronze
qMb.sum = colSums(par.list$qL[, bs.avail] * MBS.case[, bs.avail], TRUE)
par.list$A_bt[bs.avail] = qMb.sum + hyper.par.list$cc
par.list$B_bt[bs.avail] = q.sum - qMb.sum + hyper.par.list$dd
Msum.case = colSums(MBS.case[, bs.avail], TRUE)
Msum.ctrl = colSums(MBS.ctrl[, bs.avail], TRUE)
par.list$A_bf[bs.avail] = Msum.case + Msum.ctrl -
qMb.sum + hyper.par.list$ee
par.list$B_bf[bs.avail] = n.case + n.ctrl + qMb.sum - q.sum -
Msum.case - Msum.ctrl + hyper.par.list$ff
# update mu_theta, tau_theta
qLD = par.list$qL %*% par.list$qD
theta.update = UpdateTheta(par.list$mu_theta, par.list$qL, par.list$qD, qLD,
par.list$mu_rho, par.list$tau_rho,
hyper.par.list$theta_mu,
hyper.par.list$theta_tau)
par.list$mu_theta = theta.update$mu.theta
par.list$tau_theta = theta.update$tau.theta
# update mu_rho, tau_rho
rho.update = UpdateRho(par.list$mu_rho, par.list$qL, qLD,
par.list$mu_theta, par.list$tau_theta,
hyper.par.list$rho_mu, hyper.par.list$rho_tau)
par.list$mu_rho = rho.update$mu.rho
par.list$tau_rho = rho.update$tau.rho
# update qD
qD = LoopyUpdateQD(par.list, qLD,
hyper.par.list$pind_a, hyper.par.list$pind_b)
Rcpp::sourceCpp('VBEM_Update.cpp')
par.list = SetVBInitialValues(5, input.obj, hyper.pars.list)
H = matrix(par.list$mu_theta, nrow = n.case,
ncol = ncol(MBS.case), byrow = TRUE)
psi.A.A = (digamma(par.list$A_bt) - digamma(par.list$A_bf))[bs.avail]
psi.B.B = (digamma(par.list$B_bt) - digamma(par.list$B_bf))[bs.avail]
psi.A.B = (digamma(par.list$A_bf + par.list$B_bf) -
digamma(par.list$A_bt + par.list$B_bt))[bs.avail]
H.bs = t(t(MBS.case[, bs.avail]) * psi.A.A +
t(1 - MBS.case[, bs.avail]) * psi.B.B + psi.A.B)
H[, bs.avail] = H[, bs.avail] + H.bs
if (length(ss.avail) > 0) {
H[, ss.avail] = t(t(H[, ss.avail]) +
digamma(par.list$B_st[ss.avail]) -
digamma(par.list$A_st[ss.avail] +
par.list$B_st[ss.avail])) +
MSS.case[, ss.avail] * 1e+16
}
qL = LoopyUpdateQL(par.list$qL, par.list$qD, H,
par.list$mu_rho, nloop = 4)
par.list$qL = qL
# update A, B
## silver
q.sum = colSums(par.list$qL[, ss.avail], TRUE)
if (length(ss.avail) > 0) {
qMs.sum = colSums(par.list$qL[, ss.avail] * MSS.case[, ss.avail], TRUE)
par.list$A_st[ss.avail] = qMs.sum + hyper.par.list$aa[ss.avail]
par.list$B_st[ss.avail] = q.sum - qMs.sum + hyper.par.list$bb[ss.avail]
}
## bronze
qMb.sum = colSums(par.list$qL[, bs.avail] * MBS.case[, bs.avail], TRUE)
par.list$A_bt[bs.avail] = qMb.sum + hyper.par.list$cc
par.list$B_bt[bs.avail] = q.sum - qMb.sum + hyper.par.list$dd
Msum.case = colSums(MBS.case[, bs.avail], TRUE)
Msum.ctrl = colSums(MBS.ctrl[, bs.avail], TRUE)
par.list$A_bf[bs.avail] = Msum.case + Msum.ctrl -
qMb.sum + hyper.par.list$ee
par.list$B_bf[bs.avail] = n.case + n.ctrl + qMb.sum - q.sum -
Msum.case - Msum.ctrl + hyper.par.list$ff
# update mu_theta, tau_theta
qLD = par.list$qL %*% par.list$qD
theta.update = UpdateTheta(par.list$mu_theta, par.list$qL, par.list$qD, qLD,
par.list$mu_rho, par.list$tau_rho,
hyper.par.list$theta_mu,
hyper.par.list$theta_tau)
par.list$mu_theta = theta.update$mu.theta
par.list$tau_theta = theta.update$tau.theta
# update mu_rho, tau_rho
rho.update = UpdateRho(par.list$mu_rho, par.list$qL, qLD,
par.list$mu_theta, par.list$tau_theta,
hyper.par.list$rho_mu, hyper.par.list$rho_tau)
par.list$mu_rho = rho.update$mu.rho
par.list$tau_rho = rho.update$tau.rho
# update qD
qD = LoopyUpdateQD(par.list, qLD,
hyper.par.list$pind_a, hyper.par.list$pind_b)
Rcpp::sourceCpp('VBEM_Update.cpp')
par.list = SetVBInitialValues(5, input.obj, hyper.pars.list)
H = matrix(par.list$mu_theta, nrow = n.case,
ncol = ncol(MBS.case), byrow = TRUE)
psi.A.A = (digamma(par.list$A_bt) - digamma(par.list$A_bf))[bs.avail]
psi.B.B = (digamma(par.list$B_bt) - digamma(par.list$B_bf))[bs.avail]
psi.A.B = (digamma(par.list$A_bf + par.list$B_bf) -
digamma(par.list$A_bt + par.list$B_bt))[bs.avail]
H.bs = t(t(MBS.case[, bs.avail]) * psi.A.A +
t(1 - MBS.case[, bs.avail]) * psi.B.B + psi.A.B)
H[, bs.avail] = H[, bs.avail] + H.bs
if (length(ss.avail) > 0) {
H[, ss.avail] = t(t(H[, ss.avail]) +
digamma(par.list$B_st[ss.avail]) -
digamma(par.list$A_st[ss.avail] +
par.list$B_st[ss.avail])) +
MSS.case[, ss.avail] * 1e+16
}
qL = LoopyUpdateQL(par.list$qL, par.list$qD, H,
par.list$mu_rho, nloop = 4)
par.list$qL = qL
# update A, B
## silver
q.sum = colSums(par.list$qL[, ss.avail], TRUE)
if (length(ss.avail) > 0) {
qMs.sum = colSums(par.list$qL[, ss.avail] * MSS.case[, ss.avail], TRUE)
par.list$A_st[ss.avail] = qMs.sum + hyper.par.list$aa[ss.avail]
par.list$B_st[ss.avail] = q.sum - qMs.sum + hyper.par.list$bb[ss.avail]
}
## bronze
qMb.sum = colSums(par.list$qL[, bs.avail] * MBS.case[, bs.avail], TRUE)
par.list$A_bt[bs.avail] = qMb.sum + hyper.par.list$cc
par.list$B_bt[bs.avail] = q.sum - qMb.sum + hyper.par.list$dd
Msum.case = colSums(MBS.case[, bs.avail], TRUE)
Msum.ctrl = colSums(MBS.ctrl[, bs.avail], TRUE)
par.list$A_bf[bs.avail] = Msum.case + Msum.ctrl -
qMb.sum + hyper.par.list$ee
par.list$B_bf[bs.avail] = n.case + n.ctrl + qMb.sum - q.sum -
Msum.case - Msum.ctrl + hyper.par.list$ff
# update mu_theta, tau_theta
qLD = par.list$qL %*% par.list$qD
theta.update = UpdateTheta(par.list$mu_theta, par.list$qL, par.list$qD, qLD,
par.list$mu_rho, par.list$tau_rho,
hyper.par.list$theta_mu,
hyper.par.list$theta_tau)
par.list$mu_theta = theta.update$mu.theta
par.list$tau_theta = theta.update$tau.theta
# update mu_rho, tau_rho
rho.update = UpdateRho(par.list$mu_rho, par.list$qL, qLD,
par.list$mu_theta, par.list$tau_theta,
hyper.par.list$rho_mu, hyper.par.list$rho_tau)
par.list$mu_rho = rho.update$mu.rho
par.list$tau_rho = rho.update$tau.rho
# update qD
qD = LoopyUpdateQD(par.list, qLD,
hyper.par.list$pind_a, hyper.par.list$pind_b)
Rcpp::sourceCpp('VBEM_Update.cpp')
par.list = SetVBInitialValues(5, input.obj, hyper.pars.list)
H = matrix(par.list$mu_theta, nrow = n.case,
ncol = ncol(MBS.case), byrow = TRUE)
psi.A.A = (digamma(par.list$A_bt) - digamma(par.list$A_bf))[bs.avail]
psi.B.B = (digamma(par.list$B_bt) - digamma(par.list$B_bf))[bs.avail]
psi.A.B = (digamma(par.list$A_bf + par.list$B_bf) -
digamma(par.list$A_bt + par.list$B_bt))[bs.avail]
H.bs = t(t(MBS.case[, bs.avail]) * psi.A.A +
t(1 - MBS.case[, bs.avail]) * psi.B.B + psi.A.B)
H[, bs.avail] = H[, bs.avail] + H.bs
if (length(ss.avail) > 0) {
H[, ss.avail] = t(t(H[, ss.avail]) +
digamma(par.list$B_st[ss.avail]) -
digamma(par.list$A_st[ss.avail] +
par.list$B_st[ss.avail])) +
MSS.case[, ss.avail] * 1e+16
}
qL = LoopyUpdateQL(par.list$qL, par.list$qD, H,
par.list$mu_rho, nloop = 4)
par.list$qL = qL
# update A, B
## silver
q.sum = colSums(par.list$qL[, ss.avail], TRUE)
if (length(ss.avail) > 0) {
qMs.sum = colSums(par.list$qL[, ss.avail] * MSS.case[, ss.avail], TRUE)
par.list$A_st[ss.avail] = qMs.sum + hyper.par.list$aa[ss.avail]
par.list$B_st[ss.avail] = q.sum - qMs.sum + hyper.par.list$bb[ss.avail]
}
## bronze
qMb.sum = colSums(par.list$qL[, bs.avail] * MBS.case[, bs.avail], TRUE)
par.list$A_bt[bs.avail] = qMb.sum + hyper.par.list$cc
par.list$B_bt[bs.avail] = q.sum - qMb.sum + hyper.par.list$dd
Msum.case = colSums(MBS.case[, bs.avail], TRUE)
Msum.ctrl = colSums(MBS.ctrl[, bs.avail], TRUE)
par.list$A_bf[bs.avail] = Msum.case + Msum.ctrl -
qMb.sum + hyper.par.list$ee
par.list$B_bf[bs.avail] = n.case + n.ctrl + qMb.sum - q.sum -
Msum.case - Msum.ctrl + hyper.par.list$ff
# update mu_theta, tau_theta
qLD = par.list$qL %*% par.list$qD
theta.update = UpdateTheta(par.list$mu_theta, par.list$qL, par.list$qD, qLD,
par.list$mu_rho, par.list$tau_rho,
hyper.par.list$theta_mu,
hyper.par.list$theta_tau)
par.list$mu_theta = theta.update$mu.theta
par.list$tau_theta = theta.update$tau.theta
# update mu_rho, tau_rho
rho.update = UpdateRho(par.list$mu_rho, par.list$qL, qLD,
par.list$mu_theta, par.list$tau_theta,
hyper.par.list$rho_mu, hyper.par.list$rho_tau)
par.list$mu_rho = rho.update$mu.rho
par.list$tau_rho = rho.update$tau.rho
# update qD
qD = LoopyUpdateQD(par.list, qLD,
hyper.par.list$pind_a, hyper.par.list$pind_b)
Rcpp::sourceCpp('VBEM_Update.cpp')
par.list = SetVBInitialValues(5, input.obj, hyper.pars.list)
H = matrix(par.list$mu_theta, nrow = n.case,
ncol = ncol(MBS.case), byrow = TRUE)
psi.A.A = (digamma(par.list$A_bt) - digamma(par.list$A_bf))[bs.avail]
psi.B.B = (digamma(par.list$B_bt) - digamma(par.list$B_bf))[bs.avail]
psi.A.B = (digamma(par.list$A_bf + par.list$B_bf) -
digamma(par.list$A_bt + par.list$B_bt))[bs.avail]
H.bs = t(t(MBS.case[, bs.avail]) * psi.A.A +
t(1 - MBS.case[, bs.avail]) * psi.B.B + psi.A.B)
H[, bs.avail] = H[, bs.avail] + H.bs
if (length(ss.avail) > 0) {
H[, ss.avail] = t(t(H[, ss.avail]) +
digamma(par.list$B_st[ss.avail]) -
digamma(par.list$A_st[ss.avail] +
par.list$B_st[ss.avail])) +
MSS.case[, ss.avail] * 1e+16
}
qL = LoopyUpdateQL(par.list$qL, par.list$qD, H,
par.list$mu_rho, nloop = 4)
par.list$qL = qL
# update A, B
## silver
q.sum = colSums(par.list$qL[, ss.avail], TRUE)
if (length(ss.avail) > 0) {
qMs.sum = colSums(par.list$qL[, ss.avail] * MSS.case[, ss.avail], TRUE)
par.list$A_st[ss.avail] = qMs.sum + hyper.par.list$aa[ss.avail]
par.list$B_st[ss.avail] = q.sum - qMs.sum + hyper.par.list$bb[ss.avail]
}
## bronze
qMb.sum = colSums(par.list$qL[, bs.avail] * MBS.case[, bs.avail], TRUE)
par.list$A_bt[bs.avail] = qMb.sum + hyper.par.list$cc
par.list$B_bt[bs.avail] = q.sum - qMb.sum + hyper.par.list$dd
Msum.case = colSums(MBS.case[, bs.avail], TRUE)
Msum.ctrl = colSums(MBS.ctrl[, bs.avail], TRUE)
par.list$A_bf[bs.avail] = Msum.case + Msum.ctrl -
qMb.sum + hyper.par.list$ee
par.list$B_bf[bs.avail] = n.case + n.ctrl + qMb.sum - q.sum -
Msum.case - Msum.ctrl + hyper.par.list$ff
# update mu_theta, tau_theta
qLD = par.list$qL %*% par.list$qD
theta.update = UpdateTheta(par.list$mu_theta, par.list$qL, par.list$qD, qLD,
par.list$mu_rho, par.list$tau_rho,
hyper.par.list$theta_mu,
hyper.par.list$theta_tau)
par.list$mu_theta = theta.update$mu.theta
par.list$tau_theta = theta.update$tau.theta
# update mu_rho, tau_rho
rho.update = UpdateRho(par.list$mu_rho, par.list$qL, qLD,
par.list$mu_theta, par.list$tau_theta,
hyper.par.list$rho_mu, hyper.par.list$rho_tau)
par.list$mu_rho = rho.update$mu.rho
par.list$tau_rho = rho.update$tau.rho
# update qD
qD = LoopyUpdateQD(par.list, qLD,
hyper.par.list$pind_a, hyper.par.list$pind_b)
exp(-1000)
Rcpp::sourceCpp('VBEM_Update.cpp')
par.list = SetVBInitialValues(5, input.obj, hyper.pars.list)
H = matrix(par.list$mu_theta, nrow = n.case,
ncol = ncol(MBS.case), byrow = TRUE)
psi.A.A = (digamma(par.list$A_bt) - digamma(par.list$A_bf))[bs.avail]
psi.B.B = (digamma(par.list$B_bt) - digamma(par.list$B_bf))[bs.avail]
psi.A.B = (digamma(par.list$A_bf + par.list$B_bf) -
digamma(par.list$A_bt + par.list$B_bt))[bs.avail]
H.bs = t(t(MBS.case[, bs.avail]) * psi.A.A +
t(1 - MBS.case[, bs.avail]) * psi.B.B + psi.A.B)
H[, bs.avail] = H[, bs.avail] + H.bs
if (length(ss.avail) > 0) {
H[, ss.avail] = t(t(H[, ss.avail]) +
digamma(par.list$B_st[ss.avail]) -
digamma(par.list$A_st[ss.avail] +
par.list$B_st[ss.avail])) +
MSS.case[, ss.avail] * 1e+16
}
qL = LoopyUpdateQL(par.list$qL, par.list$qD, H,
par.list$mu_rho, nloop = 4)
par.list$qL = qL
# update A, B
## silver
q.sum = colSums(par.list$qL[, ss.avail], TRUE)
if (length(ss.avail) > 0) {
qMs.sum = colSums(par.list$qL[, ss.avail] * MSS.case[, ss.avail], TRUE)
par.list$A_st[ss.avail] = qMs.sum + hyper.par.list$aa[ss.avail]
par.list$B_st[ss.avail] = q.sum - qMs.sum + hyper.par.list$bb[ss.avail]
}
## bronze
qMb.sum = colSums(par.list$qL[, bs.avail] * MBS.case[, bs.avail], TRUE)
par.list$A_bt[bs.avail] = qMb.sum + hyper.par.list$cc
par.list$B_bt[bs.avail] = q.sum - qMb.sum + hyper.par.list$dd
Msum.case = colSums(MBS.case[, bs.avail], TRUE)
Msum.ctrl = colSums(MBS.ctrl[, bs.avail], TRUE)
par.list$A_bf[bs.avail] = Msum.case + Msum.ctrl -
qMb.sum + hyper.par.list$ee
par.list$B_bf[bs.avail] = n.case + n.ctrl + qMb.sum - q.sum -
Msum.case - Msum.ctrl + hyper.par.list$ff
# update mu_theta, tau_theta
qLD = par.list$qL %*% par.list$qD
theta.update = UpdateTheta(par.list$mu_theta, par.list$qL, par.list$qD, qLD,
par.list$mu_rho, par.list$tau_rho,
hyper.par.list$theta_mu,
hyper.par.list$theta_tau)
par.list$mu_theta = theta.update$mu.theta
par.list$tau_theta = theta.update$tau.theta
# update mu_rho, tau_rho
rho.update = UpdateRho(par.list$mu_rho, par.list$qL, qLD,
par.list$mu_theta, par.list$tau_theta,
hyper.par.list$rho_mu, hyper.par.list$rho_tau)
par.list$mu_rho = rho.update$mu.rho
par.list$tau_rho = rho.update$tau.rho
# update qD
qD = LoopyUpdateQD(par.list, qLD,
hyper.par.list$pind_a, hyper.par.list$pind_b)
qD
par.list = SetVBInitialValues(5, input.obj, hyper.pars.list)
par.vbfit = FitVBEMnoReg(input.obj, hyper.pars.list, par.list,
max.iter = 150, tol = 1e-6)
par.vbfit[-7]
par.list = par.vbfit
K = ncol(par.list$qL)
design.mat = DesignMatrixAppxQuadExp(K, K)
Lall = rbind(rep(0, K), design.mat$Lmat)
potentials = exp(Lall %*% par.list$mu_theta +
rowSums(Lall %*% (par.list$mu_rho * par.list$qD) * Lall))
Aconst = sum(potentials)
etio.probs = potentials/Aconst
etio.mean = design.mat$MuMat %*% cbind(etio.probs[-1])
etio.probs
etio.mean
sim.obj$pars.baseline$Mu
cbind(etio.probs, sim.obj$cell.prob.unique[1,])
round(cbind(etio.probs, sim.obj$cell.prob.unique[1,]), 4)
